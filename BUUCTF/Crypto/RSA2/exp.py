from gmpy2 import *
from Crypto.Util.number import ceil_div, long_to_bytes

e = mpz(65537)
n = mpz(248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113)
dp = mpz(905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657)

c = mpz(140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751)

def findP(e, dp):
    y = e*dp
    for x in range(1, e):
        if c_mod(y-1, x) == 0:
            # c_div返回取整的除法，所以需要再作一次判断
            if c_mod(n, c_div(y-1, x)+1) == 0:
                print("x: ", x)
                p = c_div(y-1, x)+1
                print("p: ", p)
                print("q: ", c_div(n, p))
                tmp = c_div(y-1, x)+1
                return tmp
    return -1

def decrypt(n, e, p, c):
    q = c_div(n, p)
    eulerN = (p-1) * (q-1)
    d = invert(e, eulerN)
    print("d: ", d)
    return powmod(c, d, n)
p = findP(e, dp)
# print(getd(n, e, dp))
print("p: ", p)
print("flag: ", long_to_bytes(decrypt(n, e, p, c)))
